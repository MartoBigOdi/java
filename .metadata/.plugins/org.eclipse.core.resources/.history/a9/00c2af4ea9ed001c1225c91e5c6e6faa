package ar.edu.ort.tp1.examen.clases;

import ar.edu.ort.tp1.tdas.interfaces.ListaOrdenada;

public class Deposito implements Depositante<Producto, Integer> {

	private static final String MSG_TIPO_PROD_INVALIDO = "Tipo de producto inválido";
	private static final String MSG_NO_PUDO_DEPOSITAR = "No se pudo depositar el producto.";
	private static final String MSG_PROF_INVALIDO = "Profundidad de estantería inválido";
	private static final int ALTO_ESTANTERIA = 3;
	private static final int ANCHO_ESTANTERIA = 4;
	private static final int PROFUNDIDAD_ESTANTERIA_MAX = 10;
	private static final int PROFUNDIDAD_ESTANTERIA_MIN = 2;
	private static final int FILA_PELOTA = 0;
	private static final int FILA_RAQUETA = 1;
	private static final int FILA_BOLSO = 2;
	private Estante[][] estantes;

	
	
	public Deposito(int profundidadEstanteria) {
		
		setProfundidad(profundidadEstanteria);
		
		
	}


	//Primero Validamos y lanzamos la Exception
	//Luego tenemos que poblar la estanteria con "Estantes",
	//Reccorriendo la matriz y haciendo instancias de "Estante" en cada posicion con 
	//Doble for
	private void setProfundidad(int profundidadEstanteria) {
		if(profundidadEstanteria < PROFUNDIDAD_ESTANTERIA_MIN || profundidadEstanteria > PROFUNDIDAD_ESTANTERIA_MAX) {
			throw new RuntimeException(MSG_PROF_INVALIDO);
		} 
		this.estantes = new Estante[ALTO_ESTANTERIA][ANCHO_ESTANTERIA];
		
		//Como es dos dimensiones para no confundirse utilizamos directo las FINALS que tenemos 
		//Dimensiones
		for(int i = 0; i < ALTO_ESTANTERIA; i++) {
			for(int j = 0; j < ANCHO_ESTANTERIA; j++) {
				//Creamos los Estantes dentro de la matriz con el parametro de Profundidad
				estantes[i][j] = new Estante(profundidadEstanteria);
			}
		}
	}


	
	@Override
	public void depositar(Producto elemento) {
		
		if(elemento instanceof Raqueta) {
			this.depositarProductoFila(elemento, FILA_RAQUETA);
			
		} else if (elemento instanceof Bolso) {
			this.depositarProductoFila(elemento, FILA_BOLSO);
			
		} else if (elemento instanceof Pelota) {
			this.depositarProductoFila(elemento, FILA_PELOTA);
			
		}
	}

	

	private void depositarProductoFila(Producto elemento, int filaRaqueta) {
		
		int columna = 0;
		boolean depositado = false;
		
		while(columna < estantes[filaRaqueta].length && !depositado) {
			try {
				
			} catch(RuntimeException e) {
				
			}
		}
		
	}


	
	@Override
	public Producto retirarPorId(Integer id) {
		// TODO Auto-generated method stub
		return null;
	}
	
	
	
	// TODO Completar
	/**
	 * Deposita el producto recibido en la estantería, en la fila que le corresponde
	 * según su producto, en el el primer estante que tenga lugar.
	 */
	
	/**
	 * Indica si un producto se encuentra depositado
	 * @param idProducto
	 * @return
	 */

	/**
	 * Retira un producto en base a su ID
	 */

}
